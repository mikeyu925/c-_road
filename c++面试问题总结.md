### 常考问题

---

#### c++程序内存寻址模型：

- **代码段**:存放程序的指令，是已经编译后的机器码。
- **文本段**：存储程序中的一些字符串字面量，在程序中用于显示文字，只读
- **全局数据段**：程序初始化时的**常量和全局/静态的变量**。
- **堆**：存储动态内存分配的对策，比如new malloc，，是高地址增长的。
- **栈**：存储着该程序“上下文”，比如局部变量和函数的参数值等，由编译器自动分配释放。

![img](/Users/ywh/Documents/FindGoodJob/cpp_road-master/c++面试问题总结.assets/v2-0d8aeed026fcb865e5f228ee8cbe6d7e_1440w.webp)

---

#### 为什么c++实现多态时候要将父类[基类]的析构函数设置为虚析构函数？

> 将析构函数设为虚函数，是为了防止内存泄漏。

```
解释：如果存在用基类指针指向派生类对象，这样子可以使得基类和派生类的析构函数都被调用，不会造成内存泄漏。如果不把析构函数定义为虚函数，那么只会调用基类的析构函数。
```



---

#### 对比C和C++，讲讲两者的差别。

> 1. C++具有更严格的类型检查
>
>    ```cpp
>    char * p = malloc(10);//C语言中不报错，C++中会报错，不能进行隐式转换
>    ```
>
> 2. C++三目运算符返回的是左值,c语言返回的是右值
>
>    ```cpp
>    int a = 10,b = 20;
>    (a > b ? a : b) = 100;
>    cout<<b<<endl;//打印100
>    ```
>
> 3. C语言`const`为外部链接属性，C++默认为内部链接属性
>
> 4. C语言结构体不能写函数，C++可以,并且还可以不加`struct`关键字
>
> 5. C语言中内存申请用的是malloc，释放用的是free，C++分别是new和delete
>
> 6. C++允许函数重载，但是C语言不行
>
> 7. C++允许变量定义在程序的任何部分，但是C语言要求变量定义在函数开头部分。
>
> 8. C++多了引用
>
> 9. C++用try/catch/throw取代了C语言中的setjmp()和longjmp()函数

---

#### C++和java的区别

- java中没有指针，而是引入了真正的数组；C++中的数组其实底层是指针
- C++可以在其他系统运行，但是需要不同的编码；java仅仅需要一次编码就可以在各种系统下运行
- java的多态是基于接口实现的；C++是基于抽象类实现的。
- java没有多继承，但是可以实现多个接口；C++可以多继承，但是不建议
- C++用析构函数实现垃圾回收，java自动进行内存的分配和回收。
- java在Web应用开发上有着很大的优势相比C++，并且有着丰富的框架，开发的很快

---

#### C++编译器不能优化的情况：

> 自定义结构类型，编译器不能优化。
>
> 用变量给`const`修饰的局部变量赋值，编译器不能优化。



---

#### new/delete和malloc/free 有什么差别？

> 1. new 不需要计算大小；malloc需要手动计算分配的内存大小
>2. `malloc`返回一个`void*`指针，C++类型检查很严格，不允许将`void*`赋值给其他任何指针，必须进行强转。new 返回的是指定类型的指针。
> 3. `malloc`可能申请内存失败，所以必须判断返回值来确保内存分配成功。`new`操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。
> 4. 使用`malloc/free`不会调用对象的构造函数和析构函数，`new/delete`会调用构造函数和析构函数。
> 5. 前者是c++的关键字；后者是库函数

> 建议:
>
> 1. 在删除指针后，立即把指针赋值为NULL，以免对它删除两次，对一些对象删除两次可能会产生某些问题。
> 2. `new/delete` 和 `malloc/free` 不能混搭使用。

`new`和`delete`在堆上创建、删除数组:

```cpp
int* pArr2 = new int[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
delete[] pArr2; //[]在前！
```

> 当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数

> 如果对一个`void*`指针执行`delete`操作，这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数
>
> ```cpp
> void * m = new classA;
> delete m;//不会调用析构函数，从而造成内存泄露
> ```
>
> 这是因为`静态联编`的编译方式，在编译阶段，编译器已经确定了函数的调用地址，C++不认识`void*`，不知道`void *`指向哪个函数，所以不会调用析构函数。

---

#### 重写、重载、重定义（隐藏）的区别

> 重载：同一作用域的同名函数
>
> 1. 同一个作用域
> 2. 参数个数，参数顺序，参数类型不同，和函数返回值没有关系
> 4. `const`也可以作为重载条件`do(const Teacher& t){} do(Teacher& t){}`
> 
>重写(覆盖)：
> 
>1. 有继承
> 2. 子类（派生类）重写父类（基类）的虚函数
> 3. 函数返回值，函数名字，函数参数，必须和基类中的虚函数一致
> 
>重定义（隐藏）
> 
>1. 有继承
> 2. 子类（派生类）重新定义父类（基类）的同名成员（非虚函数）

---

#### 在main执行之前和之后执行的代码可能是什么？

**main函数之前**：

- 设置栈指针
- 初始化静态`static`变量和`global`全局变量，即`.data`段的内容
- 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容
- 全局对象初始化，在`main`之前调用构造函数，这是可能会执行前的一些代码
- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
- `__attribute__((constructor))`：会在main函数执行之前被自动的执行【对于我们初始化一些在程序中使用的数据非常有用.】

**main函数执行之后**：

- 全局对象的析构函数会在main函数之后执行；
- 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
- `__attribute__((destructor))`：会在main（）函数执行之后或者exit（）被调用后被自动的执行。

---

#### c++中new的类型

- plain new：普通的new，分配内存失败会抛出异常，而不是null
- nothrow new：分配内存失败不抛出异常，而是null
- placement new：允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。
  - palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
  - placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

```cpp
#include <iostream>
#include <string>
using namespace std;
class ADT{
	int i;
	int j;
public:
	ADT(){
		i = 10;
		j = 100;
		cout << "ADT construct i=" << i << "j="<<j <<endl;
	}
	~ADT(){
		cout << "ADT destruct" << endl;
	}
};
int main()
{
	char *p = new(nothrow) char[sizeof ADT + 1];
	if (p == NULL) {
		cout << "alloc failed" << endl;
	}
	ADT *q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
	//delete q;//错误!不能在此处调用delete q;
	q->ADT::~ADT();//显示调用析构函数
	delete[] p;
	return 0;
}

//输出结果：
//ADT construct i=10j=100
//ADT destruct
```

---

#### static的用法和作用

- 隐藏：当同时编译多个文件时，所有未加static前缀的全局变量或全局函数都具有全局性。如果加了static就会对其他源文件隐藏。利用这一特性可以在不同文件中定义同文函数和变量。

- 保持变量内容的持久：如果一个局部变量被static修饰，那么它的生存期将会为整个源程序 ，但是作用域仍然在当前函数内。

- 默认初始化为0：被static修饰的变量存储在静态数据区，内存中所有的字节默认都是0x00（全局变量也在静态数据区）

- 修饰类成员对象：

  - 静态成员变量：被static修饰的成员变量不属于某个对象，而是属于类，静态数据成员要在类体外初始化，静态数据成员可以通过对象名引用，也可以通过类名来引用。静态数据成员的作用域只限于定义该类的作用域内。

  - 静态成员函数：静态成员函数也是类的一部分，而不是对象的一部分，静态成员函数的作用不是为了对象之间的沟通，而是为了能够处理静态数据成员。静态成员函数并不属于某一对象，它与任何对象都无关，因此静态成员函数没有this指针。因此，就无法对一个对象中的非静态成员进行默认访问（即在引用数据成员时不指定对象名）。

    > 静态成员函数不能被声明为const（将成员函数声明为const就是承诺不会修改该函数所属的对象）。静态成员函数也不能被声明为虚函数。

---

#### const关键字的作用

- 防止一个变量被改变，在定义该const变量时，通常需要对其进行初始化
- 作用于指针，可以指定指针指向的数据是常量，也可以指定指针是常量，或者两者兼之
- 修饰函数声明中的形参时，表面输入的参数在函数内部不可以被改变
- 修饰类的成员函数时，表明该函数是一个常函数，不能修改非mutalb的成员变量；如果有时候必须指定其返回值为const，使得返回值不能为左值
- 修饰类的成员变量时，不能在类外部进行定义，只能通过构造函数初始化列表进行初始化，并且必须有构造函数，不能在类声明中进行初始化。

---

#### 指针和引用的区别：

- 指针是一个变量，存储的是一个地址；引用相当于是一个变量的别名
- 指针可以有多级；引用只能有一级
- 指针可以为null，并且在定义时不一定非要初始化；但是引用不能为空，并且必须在定义时初始化
- 指针初始化后可以改变指向；但是引用初始化后不能改变（因为引用底层就是一个指针常量）
- 对指针进行sizeof得到的是指针的大小；对引用进行sizeof得到的是变量所占内存的大小
- 指针作为参数进行传递时，也是将实惨进行了一个拷贝，两者指向同一个地址，在函数内改变指针指向不影响实参，但是引用可以

---

#### 传递参数时，什么时候用引用，什么时候用指针，什么时候直接值传递？

如果只使用传递过来的值，而不进行修改：

- 数据对象很小（内置数据类型或小型结构），使用按值传递
- 数据对象是数组，使用指向const的指针
- 数据对象是较大的结构，使用const指针或者const引用
- 数据对象是类对象，使用const引用

如果需要进行修改：

- 内置数据类型，使用指针
- 数据对象是数组，使用指针
- 数据对象是结构，使用指针或者引用
- 数据对象是类对象，使用引用

---

#### 堆和栈的区别

- 堆是由使用者自己进行申请和释放的（容易产生内存泄露）；栈是由系统进行自动分配
- 堆默认是 1G～4G；栈默认是4M
- 堆的效率没有栈高（因为计算机在底层对栈提供支持，分配了专门的寄存器存放栈地址），堆分配的内存不是连续的（系统是用链表来存储空闲内存地址），会产生内存碎片，但是栈不会
- 堆向高地址扩展，栈向低地址扩展；

---

#### 区别一下指针类型

```cpp
int *p[10];   // 指针数组：数组中的每一个元素都是指针
int (*p)[10]; // 数组指针：指针指向的类型是一个数组int[10]
int *p(int);  // 函数声明：函数名是p，参数是int类型的，返回值是int *类型的
int (*p)(int);// 函数指针：指向的类型是返回值为int，输入参数为一个int的函数
const int * p;// 常量指针：指向的是一个常量，不能修改其值，但是可以改变指针指向
int const * p;// 常量指针：
int * const p;// 指针常量：不可以改变指针指向，但是可以改变指针指向的值
const int* const p; // 指向常量的常指针：不可以改变指针指向，也不可以改变指针指向的值
```



---

#### 被free回收的内存是立即返回给操作系统吗？

不是的，被free回收的内存会被ptmalloc使用双向链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找，如果找到合适的直接返回，避免频繁的系统的调用，占用过多的资源。

---

#### 宏定义#define和typedef有什么区别？

- 宏定义只是简单地替换，typedef是对类型起别名
- 宏定义发生在编译前的预处理阶段，typedef发生在编译阶段
- 宏定义不进行类型检查；typedef会进行数据类型检查
- 宏定义不是一个语句，后面不用加分号；typedef是语句，需要加分号

---

#### define和const的区别

- 宏定义仅仅是简单的替换，不做类型检查；但是const，编译器可以对其进行类型检查
- 宏定义发生在编译之前，但是const作用发生在编译阶段
- 宏定义是直接替换，不会分配内存，存储于程序的代码段中；const常量需要进行内存分配，存储于程序的数据段中

---

#### 变量声明和定义的区别？

- 声明不分配内存，仅仅是把变量声明的位置和类型提供给编译器，定义才分配内存。
- 一个变量可以多处声明（extern），但是只能在一处定义；

---

#### sizeof和strlen的区别？

- sizeof是关键字，strlen是函数
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。

---

#### 一个指针占多少个字节？

一个指针占内存的大小跟编译环境有关，32位环境下，指针占用大小为4字节，在64位的编译环境下的，指针的占用大小为8字节。

---

#### 数组a[]中&a和a的区别？

a和&a的值是一样的，但是意义有所区别，a指的是a[0]的地址，&a指的是数组a的地址（“数组名”代表数组第一个元素的地址，“&数组名”代表的是整个数组的地址）

a+1 = a[0]的地址+sizeof(int);(在第一个元素的地址上便宜一个数组元素的大小，即下一个元素，a[1]的地址。)

&a+1 = 数组a的地址+sizeof(a);（在数组的地址上偏移一个数组的大小，此时sizeof(a）中的a是一个数组，不是一个指针，计算出来是一个数组的大小，不是指针的大小）

> &a`的类型是`int(*)[ ],即指向数组的指针

---

#### C++中struct和class的异同

相同点：

- 两者都拥有成员函数，公有和私有部分

不同点：

- struct的成员默认是公有，class默认是私有
- struct的继承默认是公有，class默认是私有

---

#### C和C++中struct的区别

- C中不支持成员函数定义，但是C++支持成员函数定义
- C中的struct没有权限设置，仅仅是变量的集合体，而C++中的struc的成员变量可以设置权限
- C中声明结构体需要用到typedef，而C++不用

---

#### 数组名和指针（这里为指向数组首元素的指针）的区别

- 二者均可通过增减偏移量来访问数组中的元素。
- 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。
- 当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。

---

#### final和override关键字

final：阻止类的进一步派生 和 虚函数的进一步重写。

override：保证在派生类中声明的重载函数，与基类的虚函数有相同的签名；

> 比如在重写时一步小心打错了，那么编译器就把它当作新的虚函数了，就不会报错，所以加上override比较好

---

#### extern"C"的用法

在程序中加上extern "C"后，相当于告诉编译器这部分代码是C语言写的，因此要按照C语言进行编译，而不是C++

如下情况使用：

（1）C++代码中调用C语言代码；

（2）在C++中的头文件中使用；

（3）在多个人协同开发时，可能有人擅长C语言，而有人擅长C++；

---

#### 什么是野指针，什么是悬空指针？

野指针：没有初始化的指针

悬空指针：指针指向的内存已经被释放了的指针

**产生原因及解决办法：**

野指针：指针变量未及时初始化 => 定义指针变量及时初始化，要么置空。

悬空指针：指针free或delete之后没有及时置空 => 释放操作后立即置空。

---

#### C++有几种构造函数

- 默认构造函数
- 拷贝构造函数
- 初始化构造函数
- 转换构造函数

---

#### 深拷贝和浅拷贝的区别

浅拷贝：浅拷贝只是拷贝了一个指针，并没有开辟一个新的地址，拷贝的指针和原指针直线指向同一块地址。

深拷贝：深拷贝不仅拷贝值，还开辟出了一块新的空间来存放新的值，两者互不影响。

---

#### 内联函数和宏定义的区别

- 宏定义只是简单的字符串替换，不会进行类型检查；但是内联函数会在编译阶段进行类型检查
- 宏定义书写容易产生bug和歧义；内联函数不会
- 内联函数是在编译时把用到的函数代码嵌入到目标代码当中，省去了函数调用的开销，但是仅仅是建议编译器，不能保证内联

---

#### 什么是大小端存储？如何鉴别？

大端存储：高字节存储在低地址中

小端存储：低字节存储在低地址中

```cpp
#include <iostream>
using namespace std;
int main()
{
    int a = 0x1234;
    //由于int和char的长度不同，借助int型转换成char型，只会留下低地址的部分
    char c = (char)(a);
    if (c == 0x12)
        cout << "big endian" << endl;
    else if(c == 0x34)
        cout << "little endian" << endl;
}
```

---

#### volatile的用法

volatile 关键字是一种类型修饰符，遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化。

**volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。**多线程中被几个任务共享的变量需要定义为volatile类型。

---

#### mutable的用法

mutable也是为了突破const的限制而设置的。被mutable修饰的变量，将永远处于可变的状态，即使在一个const函数中。

---

#### explicit的用法

explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以**显示的方式进行类型转换**

- explicit 关键字只能用于类内部的构造函数声明上
- explicit 关键字作用于单个参数的构造函数
- 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换
