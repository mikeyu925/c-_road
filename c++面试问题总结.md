### 常考问题

---

#### c++程序内存寻址模型：

- **代码段**:存放程序的指令，是已经编译后的机器码。
- **文本段**：存储程序中的一些字符串字面量，在程序中用于显示文字，只读
- **全局数据段**：程序初始化时的**常量和全局/静态的变量**。
- **堆**：存储动态内存分配的对策，比如new malloc，，是高地址增长的。
- **栈**：存储着该程序“上下文”，比如局部变量和函数的参数值等，由编译器自动分配释放。

![img](/Users/ywh/Documents/FindGoodJob/cpp_road-master/c++面试问题总结.assets/v2-0d8aeed026fcb865e5f228ee8cbe6d7e_1440w.webp)

---

#### 为什么c++实现多态时候要将父类[基类]的析构函数设置为虚析构函数？

> 将析构函数设为虚函数，是为了防止内存泄漏。

```
解释：如果存在用基类指针指向派生类对象，这样子可以使得基类和派生类的析构函数都被调用，不会造成内存泄漏。如果不把析构函数定义为虚函数，那么只会调用基类的析构函数。
```



---

#### 对比C和C++，讲讲两者的差别。

> 1. C++具有更严格的类型检查
>
>    ```cpp
>    char * p = malloc(10);//C语言中不报错，C++中会报错，不能进行隐式转换
>    ```
>
> 2. C++三目运算符返回的是左值,c语言返回的是右值
>
>    ```cpp
>    int a = 10,b = 20;
>    (a > b ? a : b) = 100;
>    cout<<b<<endl;//打印100
>    ```
>
> 3. C语言`const`为外部链接属性，C++默认为内部链接属性
>
> 4. C语言结构体不能写函数，C++可以,并且还可以不加`struct`关键字



---

#### C++编译器不能优化的情况：

> 自定义结构类型，编译器不能优化。
>
> 用变量给`const`修饰的局部变量赋值，编译器不能优化。



---

#### `new/delete` 和 `malloc/free` 有什么差别？

> 对于 `malloc/free` :
>
> 1. 使用`malloc`程序员必须确定对象的长度,`new`不用。
> 2. `malloc`返回一个`void*`指针，C++类型检查很严格，不允许将`void*`赋值给其他任何指针，必须进行强转。
> 3. `malloc`可能申请内存失败，所以必须判断返回值来确保内存分配成功。`new`操作符能确定在调用构造函数初始化之前内存分配是成功的，所有不用显式确定调用是否成功。
> 4. 使用`malloc/free`不会调用对象的构造函数和析构函数，`new/delete`会调用构造函数和析构函数。

> ==建议==:
>
> 1. 在删除指针后，立即把指针赋值为NULL，以免对它删除两次，对一些对象删除两次可能会产生某些问题。
> 2. `new/delete` 和 `malloc/free` 不能混搭使用。

`new`和`delete`在堆上创建、删除数组:

```cpp
int* pArr2 = new int[10]{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
delete[] pArr2; //[]在前！
```

> 当创建一个对象数组的时候，必须对数组中的每一个对象调用构造函数

> 如果对一个`void*`指针执行`delete`操作，这将可能成为一个程序错误，除非指针指向的内容是非常简单的，因为它将不执行析构函数
>
> ```cpp
> void * m = new classA;
> delete m;//不会调用析构函数，从而造成内存泄露
> ```
>
> 这是因为`静态联编`的编译方式，在编译阶段，编译器已经确定了函数的调用地址，C++不认识`void*`，不知道`void *`指向哪个函数，所以不会调用析构函数。



---

#### 重写、重载、重定义

> 重载：同一作用域的同名函数
>
> 1. 同一个作用域
> 2. 参数个数，参数顺序，参数类型不同
> 3. 和函数返回值，没有关系
> 4. `const`也可以作为重载条件`do(const Teacher& t){} do(Teacher& t){}`
>
> 重写(覆盖)：
>
> 1. 有继承
> 2. 子类（派生类）重写父类（基类）的virtual函数
> 3. 函数返回值，函数名字，函数参数，必须和基类中的虚函数一致
>
> 重定义（隐藏）
>
> 1. 有继承
> 2. 子类（派生类）重新定义父类（基类）的同名成员（非virtual函数）

---

#### 在main执行之前和之后执行的代码可能是什么？

**main函数之前**：

- 设置栈指针
- 初始化静态`static`变量和`global`全局变量，即`.data`段的内容
- 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容
- 全局对象初始化，在`main`之前调用构造函数，这是可能会执行前的一些代码
- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
- `__attribute__((constructor))`：会在main函数执行之前被自动的执行【对于我们初始化一些在程序中使用的数据非常有用.】

**main函数执行之后**：

- 全局对象的析构函数会在main函数之后执行；
- 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
- `__attribute__((destructor))`：会在main（）函数执行之后或者exit（）被调用后被自动的执行。

---

#### c++中new的类型

- plain new：普通的new，分配内存失败会抛出异常，而不是null
- nothrow new：分配内存失败不抛出异常，而是null
- placement new：允许在一块已经分配成功的内存上重新构造对象或对象数组。placement new不用担心内存分配失败，因为它根本不分配内存，它做的唯一一件事情就是调用对象的构造函数。
  - palcement new的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或者他们的数组
  - placement new构造起来的对象数组，要显式的调用他们的析构函数来销毁（析构函数并不释放对象的内存），千万不要使用delete，这是因为placement new构造起来的对象或数组大小并不一定等于原来分配的内存大小，使用delete会造成内存泄漏或者之后释放内存时出现运行时错误。

```cpp
#include <iostream>
#include <string>
using namespace std;
class ADT{
	int i;
	int j;
public:
	ADT(){
		i = 10;
		j = 100;
		cout << "ADT construct i=" << i << "j="<<j <<endl;
	}
	~ADT(){
		cout << "ADT destruct" << endl;
	}
};
int main()
{
	char *p = new(nothrow) char[sizeof ADT + 1];
	if (p == NULL) {
		cout << "alloc failed" << endl;
	}
	ADT *q = new(p) ADT;  //placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
	//delete q;//错误!不能在此处调用delete q;
	q->ADT::~ADT();//显示调用析构函数
	delete[] p;
	return 0;
}

//输出结果：
//ADT construct i=10j=100
//ADT destruct
```

---

#### static的用法和作用

- 隐藏：当同时编译多个文件时，所有未加static前缀的全局变量或全局函数都具有全局性。如果加了static就会对其他源文件隐藏。利用这一特性可以在不同文件中定义同文函数和变量。

- 保持变量内容的持久：如果一个局部变量被static修饰，那么它的生存期将会为整个源程序 ，但是作用域仍然在当前函数内。

- 默认初始化为0：被static修饰的变量存储在静态数据区，内存中所有的字节默认都是0x00（全局变量也在静态数据区）

- 修饰类成员对象：

  - 静态成员变量：被static修饰的成员变量不属于某个对象，而是属于类，静态数据成员要在类体外初始化，静态数据成员可以通过对象名引用，也可以通过类名来引用。静态数据成员的作用域只限于定义该类的作用域内。

  - 静态成员函数：静态成员函数也是类的一部分，而不是对象的一部分，静态成员函数的作用不是为了对象之间的沟通，而是为了能够处理静态数据成员。静态成员函数并不属于某一对象，它与任何对象都无关，因此静态成员函数没有this指针。因此，就无法对一个对象中的非静态成员进行默认访问（即在引用数据成员时不指定对象名）。

    > 静态成员函数不能被声明为const（将成员函数声明为const就是承诺不会修改该函数所属的对象）。静态成员函数也不能被声明为虚函数。

---

#### 指针和引用的区别：

- 指针是一个变量，存储的是一个地址；引用相当于是一个变量的别名
- 指针可以有多级；引用只能有一级
- 指针可以为null，并且在定义时不一定非要初始化；但是引用不能为空，并且必须在定义时初始化
- 指针初始化后可以改变指向；但是引用初始化后不能改变（因为引用底层就是一个指针常量）
- 对指针进行sizeof得到的是指针的大小；对引用进行sizeof得到的是变量所占内存的大小
- 指针作为参数进行传递时，也是将实惨进行了一个拷贝，两者指向同一个地址，在函数内改变指针指向不影响实参，但是引用可以

---

#### 传递参数时，什么时候用引用，什么时候用指针，什么时候直接值传递？

如果只使用传递过来的值，而不进行修改：

- 数据对象很小（内置数据类型或小型结构），使用按值传递
- 数据对象是数组，使用指向const的指针
- 数据对象是较大的结构，使用const指针或者const引用
- 数据对象是类对象，使用const引用

如果需要进行修改：

- 内置数据类型，使用指针
- 数据对象是数组，使用指针
- 数据对象是结构，使用指针或者引用
- 数据对象是类对象，使用引用

---

#### 堆和栈的区别

- 堆是由使用者自己进行申请和释放的（容易产生内存泄露）；栈是由系统进行自动分配
- 堆默认是 1G～4G；栈默认是4M
- 堆的效率没有栈高（因为计算机在底层对栈提供支持，分配了专门的寄存器存放栈地址），堆分配的内存不是连续的（系统是用链表来存储空闲内存地址），会产生内存碎片，但是栈不会
- 堆向高地址扩展，栈向低地址扩展；

---

#### 区别一下指针类型

```cpp
int *p[10];   // 指针数组：数组中的每一个元素都是指针
int (*p)[10]; // 数组指针：指针指向的类型是一个数组int[10]
int *p(int);  // 函数声明：函数名是p，参数是int类型的，返回值是int *类型的
int (*p)(int);// 函数指针：指向的类型是返回值为int，输入参数为一个int的函数
const int * p;// 常量指针：指向的是一个常量，不能修改其值，但是可以改变指针指向
int const * p;// 常量指针：
int * const p;// 指针常量：不可以改变指针指向，但是可以改变指针指向的值
const int* const p; // 指向常量的常指针：不可以改变指针指向，也不可以改变指针指向的值
```

---

#### new/delete 和 malloc/free 的异同

相同点：

- 都是用于申请内存和释放内存
- 都有使用者来申请和释放

不同点：

- 前者是c++的关键字；后者是库函数
- new 返回的是指定类型的指针，malloc返回的是void *，需要进行强制转换
- new 不需要计算大小；malloc需要手动计算分配的内存大小
- 使用new在分配完内存后会调用相关对象的其构造函数，而malloc不会，只是单纯的分配内存
- 使用delete会首先调用相关对象的析构函数，然后释放内存；free只是释放内存

> new 封装了malloc

---

#### 被free回收的内存是立即返回给操作系统吗？

不是的，被free回收的内存会被ptmalloc使用双向链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找，如果找到合适的直接返回，避免频繁的系统的调用，占用过多的资源。

---

#### 宏定义#define和typedef有什么区别？

- 宏定义只是简单地替换，typedef是对类型起别名
- 宏定义发生在编译前的预处理阶段，typedef发生在编译阶段
- 宏定义不进行类型检查；typedef会进行数据类型检查
- 宏定义不是一个语句，后面不用加分号；typedef是语句，需要加分号

---

#### 变量声明和定义的区别？

- 声明不分配内存，仅仅是把变量声明的位置和类型提供给编译器，定义才分配内存。
- 一个变量可以多处声明（extern），但是只能在一处定义；

---

#### sizeof和strlen的区别？

- sizeof是关键字，strlen是函数
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是'\0'的字符串。

---

#### 一个指针占多少个字节？

一个指针占内存的大小跟编译环境有关，32位环境下，指针占用大小为4字节，在64位的编译环境下的，指针的占用大小为8字节。

---

#### 数组a[]中&a和a的区别？

a和&a的值是一样的，但是意义有所区别，a指的是a[0]的地址，&a指的是数组a的地址（“数组名”代表数组第一个元素的地址，“&数组名”代表的是整个数组的地址）

a+1 = a[0]的地址+sizeof(int);(在第一个元素的地址上便宜一个数组元素的大小，即下一个元素，a[1]的地址。)

&a+1 = 数组a的地址+sizeof(a);（在数组的地址上偏移一个数组的大小，此时sizeof(a）中的a是一个数组，不是一个指针，计算出来是一个数组的大小，不是指针的大小）
